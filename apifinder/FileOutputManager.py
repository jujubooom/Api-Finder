import os
import json
from datetime import datetime
from urllib.parse import urlparse
from .i18n import i18n

class FileOutputManager:
    """
    Êñá‰ª∂ËæìÂá∫ÁÆ°ÁêÜÂô®Á±ª
    Ë¥üË¥£Â§ÑÁêÜÂêÑÁßçÊñá‰ª∂Ê†ºÂºèÁöÑËæìÂá∫
    """

    def __init__(self, output_manager):
        """
        ÂàùÂßãÂåñÊñá‰ª∂ËæìÂá∫ÁÆ°ÁêÜÂô®

        Args:
            output_manager (OutputManager): ËæìÂá∫ÁÆ°ÁêÜÂô®ÂÆû‰æã
        """
        self.output_manager = output_manager
        self.console = output_manager.console

    def save_results(self, target_url, config_args):
        """
        ‰øùÂ≠òÊâ´ÊèèÁªìÊûúÂà∞Êñá‰ª∂

        Args:
            target_url (str): ÁõÆÊ†áURL
            config_args: ÈÖçÁΩÆÂèÇÊï∞ÂØπË±°
        """
        if not self.output_manager.output_file:
            return

        try:
            # ÂàõÂª∫ËæìÂá∫ÁõÆÂΩïÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®Ôºâ
            output_dir = os.path.dirname(self.output_manager.output_file)
            if output_dir and not os.path.exists(output_dir):
                os.makedirs(output_dir)

            file_ext = os.path.splitext(self.output_manager.output_file)[1].lower()

            # Êï∞ÊçÆÂéªÈáçÂíåÊéíÂ∫è
            unique_results = self._deduplicate_results()
            sorted_results = self._sort_results(unique_results)

            # Ê†πÊçÆÊñá‰ª∂Êâ©Â±ïÂêçÈÄâÊã©ËæìÂá∫Ê†ºÂºè
            if file_ext == '.json':
                self._save_as_json(sorted_results, target_url, config_args)
            elif file_ext == '.txt':
                self._save_as_txt(sorted_results, target_url)
            elif file_ext == '.csv':
                self._save_as_csv(sorted_results)
            elif file_ext == '.html':
                self._save_as_html(sorted_results, target_url)
            elif file_ext == '.xml':
                self._save_as_xml(sorted_results, target_url)
            elif file_ext == '.xlsx':
                self._save_as_excel(sorted_results, target_url)
            elif file_ext == '.md':
                self._save_as_markdown(sorted_results, target_url)
            else:
                # ÈªòËÆ§‰øùÂ≠ò‰∏∫JSONÊ†ºÂºè
                self.output_manager.output_file = self.output_manager.output_file.rsplit('.', 1)[0] + '.json'
                self._save_as_json(sorted_results, target_url, config_args)
                self.output_manager.print_warning(f"‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Ê†ºÂºèÔºåÂ∑≤‰øùÂ≠ò‰∏∫JSONÊ†ºÂºè")

            # ËæìÂá∫Êñá‰ª∂‰ø°ÊÅØ
            file_size = os.path.getsize(self.output_manager.output_file)
            file_size_str = self._format_file_size(file_size)

            if not self.output_manager.silent_mode:
                self.console.print(
                    f"\n[green bold]üíæAll Results saved to:[/green bold] [blue]{self.output_manager.output_file}[/blue]")
                self.console.print(
                    f"[dim]üìÅ File size: {file_size_str} | URLs: {len(sorted_results)} | Unique: {len(unique_results)} total[/dim]")

        except Exception as e:
            self.output_manager.print_error(f"Save failed: {str(e)}")

    def _deduplicate_results(self):
        """ÂéªÈáçÁªìÊûú"""
        seen_urls = set()
        unique_results = []

        for result in self.output_manager.results:
            url = result['url']
            if url not in seen_urls:
                seen_urls.add(url)
                unique_results.append(result)

        return unique_results

    def _sort_results(self, results):
        """ÊéíÂ∫èÁªìÊûú - ÊåâURLÂ≠óÊØçÈ°∫Â∫è"""
        return sorted(results, key=lambda x: x['url'])

    def _format_file_size(self, size_bytes):
        """Ê†ºÂºèÂåñÊñá‰ª∂Â§ßÂ∞è"""
        if size_bytes == 0:
            return "0 B"

        size_names = ["B", "KB", "MB", "GB"]
        i = 0
        while size_bytes >= 1024 and i < len(size_names) - 1:
            size_bytes /= 1024.0
            i += 1

        return f"{size_bytes:.1f} {size_names[i]}"

    def _save_as_json(self, results, target_url, config_args):
        """‰øùÂ≠ò‰∏∫JSONÊ†ºÂºè"""
        scan_duration = datetime.now() - self.output_manager.stats["start_time"]

        output_data = {
            "metadata": {
                "version": "1,0",
                "tool": "Api-Finder",
                "scan_time": datetime.now().isoformat(),
                "target_url": target_url,
                "scan_duration_seconds": scan_duration.total_seconds(),
                "proxy_used": getattr(config_args, 'proxy', None) if config_args else "Direct",
                "total_results": len(results),
                "unique_results": len(self._deduplicate_results())
            },
            "statistics": {
                **self.output_manager.stats,
                "start_time": self.output_manager.stats["start_time"].isoformat(),
                "success_rate": round((self.output_manager.stats["successful_requests"] / max(1,
                                                                                              self.output_manager.stats[
                                                                                                  "successful_requests"] +
                                                                                              self.output_manager.stats[
                                                                                                  "failed_requests"])) * 100,
                                      2)
            },
            "results": results,
            "configuration": {
                "timeout": getattr(config_args, 'timeout', 10) if config_args else 10,
                "delay": getattr(config_args, 'delay', 0.5) if config_args else 0.5,
                "verbose": getattr(config_args, 'verbose', False) if config_args else False,
                "silent": getattr(config_args, 'silent', False) if config_args else False,
                "random_ua": getattr(config_args, 'random', False) if config_args else False
            }
        }

        with open(self.output_manager.output_file, 'w', encoding='utf-8') as f:
            json.dump(output_data, f, ensure_ascii=False, indent=2)


    # TXT
    def _save_as_txt(self, results, target_url):
        """‰øùÂ≠ò‰∏∫TXTÊ†ºÂºè"""
        with open(self.output_manager.output_file, 'w', encoding='utf-8') as f:
            # ÂÜôÂÖ•Êñá‰ª∂Â§¥
            f.write("=" * 60 + "\n")
            f.write(f"{i18n.get('output_header')}\n")
            f.write("=" * 60 + "\n")
            f.write(f"{i18n.get('output_target')}: {target_url}\n")
            f.write(f"{i18n.get('output_scan_time')}: {datetime.now().isoformat()}\n")
            f.write(f"Êâ´ÊèèÁî®Êó∂: {(datetime.now() - self.output_manager.stats['start_time']).total_seconds():.1f}Áßí\n")
            f.write(f"{i18n.get('output_endpoints_found')}: {len(results)}\n")
            f.write(f"ÊàêÂäüËØ∑Ê±Ç: {self.output_manager.stats['successful_requests']}\n")
            f.write(f"Â§±Ë¥•ËØ∑Ê±Ç: {self.output_manager.stats['failed_requests']}\n")
            f.write("-" * 60 + "\n\n")

            # ÊåâÊù•Ê∫êÂàÜÁªÑËæìÂá∫
            sources = {}
            for result in results:
                source = result['source'] if result['source'] else 'Unknown'
                if source not in sources:
                    sources[source] = []
                sources[source].append(result)

            for source, source_results in sources.items():
                f.write(f"üìÅ Êù•Ê∫ê: {source}\n")
                f.write("-" * 30 + "\n")
                for result in source_results:
                    f.write(f"{result['url']}\n")
                f.write("\n")

    def _save_as_csv(self, results):
        """‰øùÂ≠ò‰∏∫CSVÊ†ºÂºè"""
        import csv
        with open(self.output_manager.output_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            # ÂÜôÂÖ•Â§¥ÈÉ®
            writer.writerow(['URL', 'Source', 'Timestamp', 'Source_Type', 'Domain'])

            for result in results:
                url = result['url']
                source = result['source'] if result['source'] else 'Unknown'
                timestamp = result['timestamp']

                # ÂàÜÊûêURLÁ±ªÂûã
                url_type = self._analyze_url_type(url)

                # ÊèêÂèñÂüüÂêç
                try:
                    domain = urlparse(url).netloc
                except:
                    domain = 'Unknown'

                writer.writerow([url, source, timestamp, url_type, domain])

    def _save_as_html(self, results, target_url):
        """‰øùÂ≠ò‰∏∫HTMLÊ†ºÂºè"""
        html_content = f"""<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Finder - Êâ´ÊèèÁªìÊûú</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{ 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            margin: 20px; 
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }}
        .container {{ 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 30px; 
            border-radius: 12px; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }}
        h1 {{ 
            color: #333; 
            text-align: center; 
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }}
        .stats {{ 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 20px; 
            margin: 30px 0; 
        }}
        .stat {{ 
            text-align: center; 
            padding: 20px; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            color: white;
            transition: transform 0.3s ease;
        }}
        .stat:hover {{ transform: translateY(-5px); }}
        .stat-value {{ 
            font-size: 2em; 
            font-weight: bold; 
            margin-bottom: 5px;
        }}
        .stat-label {{ 
            font-size: 0.9em; 
            opacity: 0.9;
        }}
        .info-section {{
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }}
        .info-section strong {{
            color: #007bff;
        }}
        table {{ 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 30px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }}
        th, td {{ 
            padding: 15px; 
            text-align: left; 
            border-bottom: 1px solid #eee; 
        }}
        th {{ 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }}
        tr:hover {{ 
            background-color: #f8f9ff; 
            transition: background-color 0.3s ease;
        }}
        .url-link {{ 
            color: #007bff; 
            text-decoration: none; 
            font-weight: 500;
            transition: all 0.3s ease;
            position: relative;
        }}
        .url-link:hover {{ 
            color: #0056b3;
            text-decoration: underline;
            transform: translateX(5px);
        }}
        .url-link::before {{
            content: 'üîó';
            margin-right: 5px;
            opacity: 0.7;
        }}
        .source {{ 
            color: #666; 
            font-size: 0.9em;
            background: #e9ecef;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
        }}
        .timestamp {{ 
            color: #888; 
            font-size: 0.85em;
            font-family: monospace;
        }}
        .filter-section {{
            margin: 30px 0;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }}
        .filter-section input {{ 
            padding: 12px 16px; 
            border: 2px solid #ddd; 
            border-radius: 25px; 
            font-size: 14px;
            transition: border-color 0.3s ease;
            flex: 1;
            min-width: 300px;
        }}
        .filter-section input:focus {{
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }}
        .btn {{
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.3s ease;
        }}
        .btn:hover {{
            transform: translateY(-2px);
        }}
        .url-type {{
            font-size: 0.8em;
            padding: 3px 8px;
            border-radius: 12px;
            font-weight: 500;
            text-transform: uppercase;
        }}
        .url-type.api {{ background: #d4edda; color: #155724; }}
        .url-type.js {{ background: #fff3cd; color: #856404; }}
        .url-type.css {{ background: #d1ecf1; color: #0c5460; }}
        .url-type.image {{ background: #f8d7da; color: #721c24; }}
        .url-type.other {{ background: #e2e3e5; color: #383d41; }}
        .copy-btn {{
            background: transparent;
            border: 1px solid #007bff;
            color: #007bff;
            padding: 2px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
            transition: all 0.3s ease;
        }}
        .copy-btn:hover {{
            background: #007bff;
            color: white;
        }}
        .footer {{
            margin-top: 50px;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }}
        @media (max-width: 768px) {{
            .stats {{ grid-template-columns: 1fr 1fr; }}
            .filter-section {{ flex-direction: column; }}
            .filter-section input {{ min-width: 100%; }}
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç API Finder Êâ´ÊèèÁªìÊûú</h1>

        <div class="stats">
            <div class="stat">
                <div class="stat-value">{len(results)}</div>
                <div class="stat-label">ÂèëÁé∞ÁöÑURL</div>
            </div>
            <div class="stat">
                <div class="stat-value">{self.output_manager.stats['successful_requests']}</div>
                <div class="stat-label">ÊàêÂäüËØ∑Ê±Ç</div>
            </div>
            <div class="stat">
                <div class="stat-value">{self.output_manager.stats['failed_requests']}</div>
                <div class="stat-label">Â§±Ë¥•ËØ∑Ê±Ç</div>
            </div>
            <div class="stat">
                <div class="stat-value">{(datetime.now() - self.output_manager.stats['start_time']).total_seconds():.1f}s</div>
                <div class="stat-label">Êâ´ÊèèÁî®Êó∂</div>
            </div>
        </div>

        <div class="info-section">
            <p><strong>üéØ ÁõÆÊ†áURL:</strong> <a href="{target_url}" target="_blank" class="url-link">{target_url}</a></p>
            <p><strong>üïê Êâ´ÊèèÊó∂Èó¥:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p><strong>üìä Êâ´ÊèèÁä∂ÊÄÅ:</strong> {"‚úÖ ÂÆåÊàê" if len(results) > 0 else "‚ö†Ô∏è Êú™ÂèëÁé∞APIÁ´ØÁÇπ"}</p>
        </div>

        <div class="filter-section">
            <input type="text" id="filterInput" placeholder="üîç ËøáÊª§URLÔºàÊîØÊåÅÊ≠£ÂàôË°®ËææÂºèÔºâ..." onkeyup="filterResults()">
            <button class="btn" onclick="exportResults()">üìÑ ÂØºÂá∫ÁªìÊûú</button>
            <button class="btn" onclick="clearFilter()">üóëÔ∏è Ê∏ÖÈô§ËøáÊª§</button>
        </div>

        <table id="resultsTable">
            <thead>
                <tr>
                    <th>üîó URL</th>
                    <th>üìÅ Êù•Ê∫ê</th>
                    <th>üè∑Ô∏è Á±ªÂûã</th>
                    <th>‚è∞ Êó∂Èó¥</th>
                    <th>üõ†Ô∏è Êìç‰Ωú</th>
                </tr>
            </thead>
            <tbody>
"""

        for result in results:
            url = result['url']
            source = result['source'] if result['source'] else 'Unknown'
            timestamp = result['timestamp']
            url_type = self._analyze_url_type(url)

            # Ê†ºÂºèÂåñÊó∂Èó¥
            try:
                time_obj = datetime.fromisoformat(timestamp)
                formatted_time = time_obj.strftime('%H:%M:%S')
            except:
                formatted_time = timestamp

            # ÁîüÊàêÁ±ªÂûãÊ†áÁ≠æÁöÑCSSÁ±ª
            type_class = 'api' if 'api' in url.lower() else 'js' if '.js' in url else 'css' if '.css' in url else 'image' if any(
                ext in url.lower() for ext in ['.jpg', '.png', '.gif', '.svg']) else 'other'

            html_content += f"""
                <tr>
                    <td>
                        <a href="{url}" class="url-link" target="_blank" rel="noopener noreferrer">{url}</a>
                    </td>
                    <td><span class="source">{source.split('/')[-1] if source else 'Unknown'}</span></td>
                    <td><span class="url-type {type_class}">{url_type}</span></td>
                    <td><span class="timestamp">{formatted_time}</span></td>
                    <td>
                        <button class="copy-btn" onclick="copyToClipboard('{url}')">üìã Â§çÂà∂</button>
                    </td>
                </tr>
"""

        html_content += f"""
            </tbody>
        </table>

        <div class="footer">
            <p>Generated by <strong>API Finder</strong> ‚Ä¢ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p>ÊÄªÂÖ±ÊâæÂà∞ <strong>{len(results)}</strong> ‰∏™URL</p>
        </div>
    </div>

    <script>
        function filterResults() {{
            const input = document.getElementById('filterInput');
            const filter = input.value.toLowerCase();
            const table = document.getElementById('resultsTable');
            const rows = table.getElementsByTagName('tr');

            for (let i = 1; i < rows.length; i++) {{
                const url = rows[i].getElementsByTagName('td')[0].textContent.toLowerCase();
                const source = rows[i].getElementsByTagName('td')[1].textContent.toLowerCase();
                const type = rows[i].getElementsByTagName('td')[2].textContent.toLowerCase();

                if (url.indexOf(filter) > -1 || source.indexOf(filter) > -1 || type.indexOf(filter) > -1) {{
                    rows[i].style.display = '';
                }} else {{
                    rows[i].style.display = 'none';
                }}
            }}
        }}

        function clearFilter() {{
            document.getElementById('filterInput').value = '';
            filterResults();
        }}

        function copyToClipboard(url) {{
            navigator.clipboard.writeText(url).then(function() {{
                // ÂàõÂª∫ÊèêÁ§∫
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Â∑≤Â§çÂà∂';
                btn.style.background = '#28a745';
                btn.style.color = 'white';

                setTimeout(() => {{
                    btn.textContent = originalText;
                    btn.style.background = 'transparent';
                    btn.style.color = '#007bff';
                }}, 1000);
            }});
        }}

        function exportResults() {{
            const table = document.getElementById('resultsTable');
            const rows = table.getElementsByTagName('tr');
            let csv = 'Â∫èÂè∑,URL,Êù•Ê∫ê,Á±ªÂûã,Êó∂Èó¥\\n';

            for (let i = 1; i < rows.length; i++) {{
                if (rows[i].style.display !== 'none') {{
                    const cells = rows[i].getElementsByTagName('td');
                    const url = cells[0].textContent;
                    const source = cells[1].textContent;
                    const type = cells[2].textContent;
                    const time = cells[3].textContent;
                    csv += `${{i}},"${{url}}","${{source}}","${{type}}","${{time}}"\\n`;
                }}
            }}

            const blob = new Blob([csv], {{ type: 'text/csv;charset=utf-8;' }});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'api_finder_results.csv';
            link.click();
        }}

        // Ê∑ªÂä†ÈîÆÁõòÂø´Êç∑ÈîÆ
        document.addEventListener('keydown', function(e) {{
            if (e.ctrlKey && e.key === 'f') {{
                e.preventDefault();
                document.getElementById('filterInput').focus();
            }}
        }});
    </script>
</body>
</html>
"""

        with open(self.output_manager.output_file, 'w', encoding='utf-8') as f:
            f.write(html_content)

    def _save_as_xml(self, results, target_url):
        """‰øùÂ≠ò‰∏∫XMLÊ†ºÂºè"""
        xml_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<api_scan_results>
    <metadata>
        <tool>Api-Finder</tool>
        <version>0.3.1</version>
        <scan_time>{datetime.now().isoformat()}</scan_time>
        <target_url>{target_url}</target_url>
        <total_results>{len(results)}</total_results>
    </metadata>
    <statistics>
        <successful_requests>{self.output_manager.stats['successful_requests']}</successful_requests>
        <failed_requests>{self.output_manager.stats['failed_requests']}</failed_requests>
        <api_endpoints>{self.output_manager.stats['api_endpoints']}</api_endpoints>
        <scan_duration>{(datetime.now() - self.output_manager.stats['start_time']).total_seconds():.1f}</scan_duration>
    </statistics>
    <results>
"""

        for result in results:
            url = result['url']
            source = result['source'] if result['source'] else 'Unknown'
            timestamp = result['timestamp']
            url_type = self._analyze_url_type(url)

            xml_content += f"""
        <result>
            <url><![CDATA[{url}]]></url>
            <source><![CDATA[{source}]]></source>
            <type>{url_type}</type>
            <timestamp>{timestamp}</timestamp>
        </result>
"""

        xml_content += """
    </results>
</api_scan_results>
"""

        with open(self.output_manager.output_file, 'w', encoding='utf-8') as f:
            f.write(xml_content)

    def _save_as_excel(self, results, target_url):
        """‰øùÂ≠ò‰∏∫ExcelÊ†ºÂºè"""
        try:
            import openpyxl
            from openpyxl.styles import Font, Alignment, PatternFill

            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "APIÊâ´ÊèèÁªìÊûú"

            # ËÆæÁΩÆÊ†áÈ¢òÊ†∑Âºè
            title_font = Font(bold=True, size=12)
            header_fill = PatternFill(start_color="E8F4F8", end_color="E8F4F8", fill_type="solid")

            # ÂÜôÂÖ•Â§¥ÈÉ®‰ø°ÊÅØ
            ws['A1'] = 'API Finder Êâ´ÊèèÁªìÊûú'
            ws['A1'].font = Font(bold=True, size=16)
            ws['A2'] = f'ÁõÆÊ†áURL: {target_url}'
            ws['A3'] = f'Êâ´ÊèèÊó∂Èó¥: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}'
            ws['A4'] = f'ÂèëÁé∞URLÊï∞Èáè: {len(results)}'

            # ËÆæÁΩÆË°®Ê†ºÂ§¥ÈÉ®
            headers = ['URL', 'Êù•Ê∫ê', 'Á±ªÂûã', 'ÂüüÂêç', 'Êó∂Èó¥Êà≥']
            for i, header in enumerate(headers, 1):
                cell = ws.cell(row=6, column=i, value=header)
                cell.font = title_font
                cell.fill = header_fill

            # ÂÜôÂÖ•Êï∞ÊçÆ
            for row, result in enumerate(results, 7):
                ws.cell(row=row, column=1, value=result['url'])
                ws.cell(row=row, column=2, value=result['source'] if result['source'] else 'Unknown')
                ws.cell(row=row, column=3, value=self._analyze_url_type(result['url']))
                try:
                    domain = urlparse(result['url']).netloc
                except:
                    domain = 'Unknown'
                ws.cell(row=row, column=4, value=domain)
                ws.cell(row=row, column=5, value=result['timestamp'])

            # Ëá™Âä®Ë∞ÉÊï¥ÂàóÂÆΩ
            for column in ws.columns:
                max_length = 0
                column_letter = column[0].column_letter
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = min(max_length + 2, 50)
                ws.column_dimensions[column_letter].width = adjusted_width

            wb.save(self.output_manager.output_file)

        except ImportError:
            self.output_manager.print_error("ÈúÄË¶ÅÂÆâË£ÖopenpyxlÂ∫ìÊâçËÉΩ‰øùÂ≠òExcelÊ†ºÂºè: pip install openpyxl")
            # ÂõûÈÄÄÂà∞CSVÊ†ºÂºè
            self.output_manager.output_file = self.output_manager.output_file.rsplit('.', 1)[0] + '.csv'
            self._save_as_csv(results)

    def _save_as_markdown(self, results, target_url):
        """‰øùÂ≠ò‰∏∫MarkdownÊ†ºÂºè"""
        md_content = f"""# üîç API Finder Êâ´ÊèèÁªìÊûú

## üìä Êâ´Êèè‰ø°ÊÅØ

- **ÁõÆÊ†áURL**: {target_url}
- **Êâ´ÊèèÊó∂Èó¥**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **ÂèëÁé∞URLÊï∞Èáè**: {len(results)}
- **ÊàêÂäüËØ∑Ê±Ç**: {self.output_manager.stats['successful_requests']}
- **Â§±Ë¥•ËØ∑Ê±Ç**: {self.output_manager.stats['failed_requests']}
- **Êâ´ÊèèÁî®Êó∂**: {(datetime.now() - self.output_manager.stats['start_time']).total_seconds():.1f}Áßí

## üéØ ÂèëÁé∞ÁöÑAPIÁ´ØÁÇπ

| URL | Êù•Ê∫ê | Á±ªÂûã | Êó∂Èó¥ |
|-----|------|------|------|
"""

        for result in results:
            url = result['url']
            source = result['source'] if result['source'] else 'Unknown'
            source_display = source.split('/')[-1] if source else 'Unknown'
            url_type = self._analyze_url_type(url)

            try:
                time_obj = datetime.fromisoformat(result['timestamp'])
                formatted_time = time_obj.strftime('%H:%M:%S')
            except:
                formatted_time = result['timestamp']

            md_content += f"| {url} | {source_display} | {url_type} | {formatted_time} |\n"

        md_content += f"""

## üìà ÁªüËÆ°‰ø°ÊÅØ

- ÊÄªURLÊï∞Èáè: {len(results)}
- ÂîØ‰∏ÄURLÊï∞Èáè: {len(self._deduplicate_results())}
- ÊàêÂäüÁéá: {round((self.output_manager.stats['successful_requests'] / max(1, self.output_manager.stats['successful_requests'] + self.output_manager.stats['failed_requests'])) * 100, 2)}%

---
*ÁîüÊàêÂ∑•ÂÖ∑: Api-Finder v0.3.1*
"""

        with open(self.output_manager.output_file, 'w', encoding='utf-8') as f:
            f.write(md_content)

    def _analyze_url_type(self, url):
        """ÂàÜÊûêURLÁ±ªÂûã"""
        url_lower = url.lower()

        if any(keyword in url_lower for keyword in ['api', 'rest', 'graphql']):
            return 'API'
        elif url_lower.endswith('.json'):
            return 'JSON'
        elif url_lower.endswith('.xml'):
            return 'XML'
        elif any(keyword in url_lower for keyword in ['ajax', 'xhr']):
            return 'AJAX'
        elif any(keyword in url_lower for keyword in ['.php', '.jsp', '.asp']):
            return 'Dynamic'
        elif any(keyword in url_lower for keyword in ['.js', '.css', '.html']):
            return 'Static'
        else:
            return 'Other'